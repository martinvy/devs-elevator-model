<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>basesimulator &mdash; PythonPDEVS 2.3.1 documentation</title>
    
    <link rel="stylesheet" href="../static/default.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="PythonPDEVS 2.3.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">PythonPDEVS 2.3.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for basesimulator</h1><div class="highlight"><pre>
<span class="c"># Copyright 2014 Modelling, Simulation and Design Lab (MSDL) at </span>
<span class="c"># McGill University and the University of Antwerp (http://msdl.cs.mcgill.ca/)</span>
<span class="c"># </span>
<span class="c"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c"># you may not use this file except in compliance with the License.</span>
<span class="c"># You may obtain a copy of the License at</span>
<span class="c">#</span>
<span class="c">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c">#</span>
<span class="c"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c"># See the License for the specific language governing permissions and</span>
<span class="c"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Actual simulation kernel</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pypdevs.solver</span> <span class="kn">import</span> <span class="n">Solver</span>

<span class="kn">from</span> <span class="nn">pypdevs.util</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pypdevs.messageScheduler</span> <span class="kn">import</span> <span class="n">MessageScheduler</span>
<span class="kn">from</span> <span class="nn">pypdevs.message</span> <span class="kn">import</span> <span class="n">NetworkMessage</span>
<span class="kn">from</span> <span class="nn">pypdevs.DEVS</span> <span class="kn">import</span> <span class="n">RootDEVS</span><span class="p">,</span> <span class="n">CoupledDEVS</span><span class="p">,</span> <span class="n">AtomicDEVS</span>
<span class="kn">from</span> <span class="nn">pypdevs.statesavers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">pypdevs.logger</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">pypdevs.tracer</span> <span class="kn">import</span> <span class="n">Tracers</span>
<span class="kn">from</span> <span class="nn">pypdevs.activityVisualisation</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">Queue</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">queue</span> <span class="kn">as</span> <span class="nn">Queue</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<div class="viewcode-block" id="BaseSimulator"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator">[docs]</a><span class="k">class</span> <span class="nc">BaseSimulator</span><span class="p">(</span><span class="n">Solver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The BaseSimulator class, this is the actual simulation kernel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BaseSimulator.__init__"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">server</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        :param name: the name of the kernel</span>
<span class="sd">        :param model: the model to initialise the kernel with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Solver</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inits</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">server</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporary_irreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_msg_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_DSDEVS</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activity_tracking</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memoization</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_activities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_sent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_recv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock_request</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.resetSimulation"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.resetSimulation">[docs]</a>    <span class="k">def</span> <span class="nf">resetSimulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the simulation kernel to the saved version; can only be invoked after a previous simulation run.</span>

<span class="sd">        :param scheduler: the scheduler to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">model_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inits</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporary_irreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_msg_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">proxy</span><span class="o">.</span><span class="n">saveAndProcessModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pickled_model</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For pickling</span>

<span class="sd">        :param retdict: dictionary containing the attributes to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inits</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">retdict</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">retdict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For pickling</span>

<span class="sd">        :returns: dictionary containing attributes and their values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unpicklable</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s">&quot;instancemethod&quot;</span><span class="p">,</span>
                                <span class="s">&quot;lock&quot;</span><span class="p">,</span>
                                <span class="s">&quot;_Event&quot;</span><span class="p">,</span>
                                <span class="s">&quot;Thread&quot;</span><span class="p">,</span>
                                <span class="s">&quot;method-wrapper&quot;</span><span class="p">,</span>
                                <span class="s">&quot;builtin_function_or_method&quot;</span><span class="p">])</span>
        <span class="n">unnecessary</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s">&quot;input_scheduler&quot;</span><span class="p">,</span>
                                <span class="s">&quot;inqueue&quot;</span><span class="p">,</span>
                                <span class="s">&quot;actions&quot;</span><span class="p">,</span>
                                <span class="s">&quot;server&quot;</span><span class="p">,</span>
                                <span class="s">&quot;msg_sent&quot;</span><span class="p">,</span>
                                <span class="s">&quot;msg_recv&quot;</span><span class="p">,</span>
                                <span class="s">&quot;send_msg_counter&quot;</span><span class="p">,</span>
                                <span class="s">&quot;output_queue&quot;</span><span class="p">,</span>
                                <span class="s">&quot;accumulator&quot;</span><span class="p">,</span>
                                <span class="s">&quot;control_msg&quot;</span><span class="p">,</span>
                                <span class="s">&quot;transitioning&quot;</span><span class="p">,</span>
                                <span class="s">&quot;Vchange&quot;</span><span class="p">,</span>
                                <span class="s">&quot;V&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">in</span> <span class="n">unpicklable</span><span class="p">:</span>
                <span class="c"># unpicklable, so don&#39;t copy it</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;tracers&quot;</span><span class="p">:</span>
                <span class="n">retdict</span><span class="p">[</span><span class="s">&quot;tracers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">tracers_init</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unnecessary</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;__&quot;</span><span class="p">)):</span>
                <span class="n">retdict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retdict</span>

<div class="viewcode-block" id="BaseSimulator.inits"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.inits">[docs]</a>    <span class="k">def</span> <span class="nf">inits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the simulation kernel, this is split up from the constructor to</span>
<span class="sd">        make it possible to reset the kernel without reconstructing the kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_time_check</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_condition</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_outgoing</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relocation_pending</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Mattern&#39;s GVT algorithm</span>
        <span class="c"># 0 = white1</span>
        <span class="c"># 1 = red1</span>
        <span class="c"># 2 = white2</span>
        <span class="c"># 3 = red2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulator</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_msg_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span> <span class="o">=</span> <span class="n">MessageScheduler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="c"># Acquire the lock ASAP, to prevent simulation during/after shutdown</span>
        <span class="c"># it has to be released as soon as the simulation is commenced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_gvt</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span> <span class="o">=</span> <span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_finish</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getProxy"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getProxy">[docs]</a>    <span class="k">def</span> <span class="nf">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a proxy to the specified rank.</span>

<span class="sd">        Method will simply forward the request to its server object.</span>

<span class="sd">        :param rank: the rank to return a proxy to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getSelfProxy"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getSelfProxy">[docs]</a>    <span class="k">def</span> <span class="nf">getSelfProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a proxy to ourself.</span>

<span class="sd">        This method is useful in case the underlying code has no idea on which node it is running and it simply wants to contact its kernel.</span>
<span class="sd">        It also differs from simply calling the code on the object of the kernel, as this provides a wrapper for asynchronous local invocation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setTerminationTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setTerminationTime">[docs]</a>    <span class="k">def</span> <span class="nf">setTerminationTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the time at which simulation should stop, setting this will override</span>
<span class="sd">        the local simulation condition.</span>

<span class="sd">        :param time: the time at which the simulation should stop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="c"># Set it in case the kernel was already stopped and an invalidation happened</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.sendModel"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.sendModel">[docs]</a>    <span class="k">def</span> <span class="nf">sendModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">,</span> <span class="n">scheduler_type</span><span class="p">,</span> <span class="n">flattened</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send a model to this simulation kernel, as this one will be simulated</span>

<span class="sd">        :param model: the model to set</span>
<span class="sd">        :param model_ids: list containing all models in order of their model_ids</span>
<span class="sd">        :param scheduler_type: string representation of the scheduler to use</span>
<span class="sd">        :param flattened: whether or not the model had its ports decoupled from the models to allow pickling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span> <span class="o">=</span> <span class="n">flattened</span>
        <span class="k">if</span> <span class="n">flattened</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">unflattenConnections</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span> <span class="o">=</span> <span class="n">model_ids</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">)</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">local</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">remotes</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">atomic</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">location</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="c"># Model is simulated here</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomic</span>
                <span class="n">local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atomic</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">location</span>
                <span class="n">remotes</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">local</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">CoupledDEVS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">RootDEVS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">component_set</span><span class="p">,</span> <span class="n">scheduler_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">AtomicDEVS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">RootDEVS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">,</span> <span class="p">[</span><span class="n">model</span><span class="p">],</span> <span class="n">scheduler_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">activities</span> <span class="o">=</span> <span class="p">{}</span>
</div>
<div class="viewcode-block" id="BaseSimulator.migrateTo"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.migrateTo">[docs]</a>    <span class="k">def</span> <span class="nf">migrateTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Migrate all models to a new destination</span>

<span class="sd">        :param destination: destination of all models specified hereafter</span>
<span class="sd">        :param model_ids: iterable containing all models to migrate simultaneously</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Assumes that the simlock is already acquired</span>
        <span class="c"># Make sure that the model that we are migrating is local here</span>
        <span class="c">#assert info(&quot;Migrating &quot; + str(model_ids) + &quot; to &quot; + str(destination))</span>
        <span class="n">models</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span>
                    <span class="s">&quot;Cannot migrate model that is not local to the source!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">relocatable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span>
                    <span class="s">&quot;Model </span><span class="si">%s</span><span class="s"> is fixed and is not allowed to be relocated&quot;</span> 
                    <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">getModelFullName</span><span class="p">())</span>
            <span class="n">models</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">])</span>
        <span class="n">destination</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">destination</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c"># Model is already there...</span>
            <span class="k">return</span>
        <span class="c">#assert info(&quot;Migration approved of %s from node %d to node %d&quot; % (model_ids, self.name, destination))</span>

        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="c"># All models are gone here, so remove them from the scheduler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">unschedule</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">destination</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">notifyMigration</span><span class="p">(</span><span class="n">model_ids</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>

        <span class="n">remote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
        <span class="c"># NOTE Due to the revertions, the outputQueue will be completely empty because:</span>
        <span class="c">#        - messages before the GVT are cleaned up due to fossil collection</span>
        <span class="c">#        - messages after the GVT are cleaned up due to the revertion that sends anti-messages</span>
        <span class="c"># Furthermore, the state vector will be as small as possible to reduce the amount of data that has to be transferred</span>
        <span class="c"># The inputqueue requires some small processing: all future incomming messages for the model that gets migrated</span>
        <span class="c"># needs to be found. The processed messages list should be empty, with the following reason as the outputQueue.</span>
        <span class="n">remote</span><span class="o">.</span><span class="n">messageTransfer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">model_ids</span><span class="p">))</span>
        <span class="n">bundled_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">model_id</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">time_last</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">time_next</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">]</span>
        <span class="c">#TODO clean up this code to use the bundling somewhat more efficient</span>
        <span class="n">remote</span><span class="o">.</span><span class="n">activateModels</span><span class="p">(</span><span class="n">bundled_models</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="c"># No need to ask the new node whether or not there are specific nodes that also have to be informed</span>
            <span class="c">#remote.activateModel(model.model_id, (model.time_last, model.time_next, model.state))</span>
            <span class="c"># Delete our representation of the model</span>
            <span class="n">model</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">model</span><span class="o">.</span><span class="n">old_states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">model_id</span><span class="p">]</span>

        <span class="c"># Remove the model from the component_set of the RootDEVS</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">component_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">component_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">components</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">models</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">model_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">destination</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">destination</span>

        <span class="c"># Now update the time_next and time_last values here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.notifyMigration"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.notifyMigration">[docs]</a>    <span class="k">def</span> <span class="nf">notifyMigration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notify the migration of a model_id to a new destination</span>

<span class="sd">        :param model_ids: the model_ids that gets moved</span>
<span class="sd">        :param destination: the node location that now hosts the model_id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">destination</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c"># No need to notify ourselves, simply here for safety as it shouldn&#39;t be called</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">destination</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">destination</span>
</div>
<div class="viewcode-block" id="BaseSimulator.requestMigrationLock"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.requestMigrationLock">[docs]</a>    <span class="k">def</span> <span class="nf">requestMigrationLock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Request this kernel to lock itself ASAP to allow a relocation to happen. This will invoke the *notifyLocked* method on the controller as soon as locking succeeded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relocation_pending</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">notifyLocked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.migrationUnlock"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.migrationUnlock">[docs]</a>    <span class="k">def</span> <span class="nf">migrationUnlock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unlocks the simulation lock remotely.</span>

<span class="sd">        .. warning:: do not use this function, unless you fully understand what you are doing!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relocation_pending</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.activateModels"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.activateModels">[docs]</a>    <span class="k">def</span> <span class="nf">activateModels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bundle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the activateModel method on a list of arguments</span>

<span class="sd">        :param bundle: a bundle of messages to send, each entry should contain a tuple that can be expanded for the call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">current_state</span> <span class="ow">in</span> <span class="n">bundle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activateModel</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="n">current_state</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.activateModel"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.activateModel">[docs]</a>    <span class="k">def</span> <span class="nf">activateModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">current_state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate the model at this kernel, thus allowing the kernel to use (and schedule) this model. </span>
<span class="sd">        Note that a revert to the GVT has to happen before calling this function, since the old_states </span>
<span class="sd">        are not transferred and thus reverting is impossible.</span>

<span class="sd">        :param model_id: the id of the model that has to be activated</span>
<span class="sd">        :param currentState: the current state of the model that gets migrated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
        <span class="n">old_location</span> <span class="o">=</span> <span class="n">new_model</span><span class="o">.</span><span class="n">location</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">component_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_model</span><span class="o">.</span><span class="n">model_id</span><span class="p">)</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">time_last</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">time_next</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">old_states</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_saver</span><span class="p">(</span><span class="n">new_model</span><span class="o">.</span><span class="n">time_last</span><span class="p">,</span> 
                                                <span class="n">new_model</span><span class="o">.</span><span class="n">time_next</span><span class="p">,</span> 
                                                <span class="n">new_model</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> 
                                                <span class="mf">0.0</span><span class="p">,</span> 
                                                <span class="p">{},</span> 
                                                <span class="mf">0.0</span><span class="p">)]</span>
        <span class="c"># It is a new model, so add it to the scheduler too</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">new_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
</div>
<div class="viewcode-block" id="BaseSimulator.messageTransfer"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.messageTransfer">[docs]</a>    <span class="k">def</span> <span class="nf">messageTransfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extraction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfer the messages during a model transfer</span>

<span class="sd">        :param extraction: the extraction generated by the *messageScheduler*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">extraction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.notifySend"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.notifySend">[docs]</a>    <span class="k">def</span> <span class="nf">notifySend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notify the simulation kernel of the sending of a message. Needed for</span>
<span class="sd">        GVT calculation.</span>

<span class="sd">        :param destination: the name of the simulation kernel that will receive the sent message</span>
<span class="sd">        :param timestamp: simulation time at which the message is sent</span>
<span class="sd">        :param color: color of the message being sent (for Mattern&#39;s algorithm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_sent</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">color</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">color</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.notifyReceive"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.notifyReceive">[docs]</a>    <span class="k">def</span> <span class="nf">notifyReceive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notify the simulation kernel of the receiving of a message. Needed for</span>
<span class="sd">        GVT calculation.</span>

<span class="sd">        :param color: the color of the received message (for Mattern&#39;s algorithm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#assert debug(&quot;Received message with color: &quot; + str(color))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_recv</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">color</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">color</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="n">color</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.waitUntilOK"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.waitUntilOK">[docs]</a>    <span class="k">def</span> <span class="nf">waitUntilOK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns as soon as all messages to this simulation kernel are received.</span>
<span class="sd">        Needed due to Mattern&#39;s algorithm. Uses events to prevent busy looping.</span>

<span class="sd">        :param vector: the vector number to wait for. Should be 0 for colors 0 and 1, should be 1 for colors 2 and 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">vector</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> 
                   <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="c"># Use an event to prevent busy looping</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="n">vector</span><span class="p">]</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="n">vector</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="c"># Free the lock</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.receiveControl"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.receiveControl">[docs]</a>    <span class="k">def</span> <span class="nf">receiveControl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Receive a GVT control message and process it. Method will block until the GVT is actually found, so make this an asynchronous call, or run it on a seperate thread.</span>

<span class="sd">        This code implements Mattern&#39;s algorithm with a slight modification: it uses 4 different colours to distinguish two subsequent runs. Furthermore, it always requires 2 complete passes before a GVT is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span> <span class="o">=</span> <span class="n">msg</span>
        <span class="n">m_clock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m_send</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">waiting_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">accumulating_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
            <span class="n">prevcolor</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>
            <span class="n">finished</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> 
                        <span class="ow">not</span> <span class="n">first</span> <span class="ow">and</span> 
                        <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allZeroDict</span><span class="p">(</span><span class="n">waiting_vector</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;GVT bug detected&quot;</span><span class="p">)</span>
                <span class="n">waiting_vector</span> <span class="o">=</span> <span class="n">accumulating_vector</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">accumulating_vector</span>
                <span class="n">accumulating_vector</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">finished</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>
                <span class="n">gvt</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m_clock</span><span class="p">,</span> <span class="n">m_send</span><span class="p">))</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got GVT&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">gvt</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;GVT is decreasing&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">accumulator</span> <span class="o">=</span> <span class="n">waiting_vector</span>
                <span class="n">use_last_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relocator</span><span class="o">.</span><span class="n">useLastStateOnly</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">setGVT</span><span class="p">(</span><span class="n">gvt</span><span class="p">,</span> 
                                                <span class="p">[],</span> 
                                                <span class="n">use_last_state</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">waitUntilOK</span><span class="p">(</span><span class="n">prevcolor</span><span class="p">)</span>
                <span class="n">addDict</span><span class="p">(</span><span class="n">waiting_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">prevcolor</span><span class="p">])</span>
                <span class="n">addDict</span><span class="p">(</span><span class="n">accumulating_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">color</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">prevcolor</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span><span class="p">:</span>
                    <span class="n">localtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">localtime</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
                <span class="n">ntime</span> <span class="o">=</span> <span class="n">localtime</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">m_clock</span><span class="p">,</span> <span class="n">localtime</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="n">ntime</span><span class="p">,</span> 
                       <span class="nb">min</span><span class="p">(</span><span class="n">m_send</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span><span class="p">),</span> 
                       <span class="n">waiting_vector</span><span class="p">,</span> 
                       <span class="n">accumulating_vector</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_LP</span><span class="o">.</span><span class="n">receiveControl</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setIrreversible"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setIrreversible">[docs]</a>    <span class="k">def</span> <span class="nf">setIrreversible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark this node as **temporary** irreversible, meaning that it can simply be made reversible later on. </span>
<span class="sd">        This can be used when all nodes are ran at a single node due to relocation, though future relocations might again move some nodes away.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporary_irreversible</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseSimulator.unsetIrreversible"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.unsetIrreversible">[docs]</a>    <span class="k">def</span> <span class="nf">unsetIrreversible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmark this node as **temporary** irreversible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporary_irreversible</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setGVT"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setGVT">[docs]</a>    <span class="k">def</span> <span class="nf">setGVT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gvt</span><span class="p">,</span> <span class="n">activities</span><span class="p">,</span> <span class="n">last_state_only</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the GVT of this simulation kernel. This value should not be smaller than</span>
<span class="sd">        the current GVT (this would be impossible for a correct GVT calculation). Also</span>
<span class="sd">        cleans up the input, output and state buffers used due to time-warp.</span>
<span class="sd">        Furthermore, it also processes all messages scheduled before the GVT.</span>

<span class="sd">        :param gvt: the desired GVT</span>
<span class="sd">        :param activities: the activities of all seperate nodes as a list</span>
<span class="sd">        :param last_state_only: whether or not all states should be considered or only the last</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># GVT is just a time, it does not contain an age field!</span>
        <span class="c">#assert debug(&quot;Got setGVT&quot;)</span>
        <span class="k">if</span> <span class="n">gvt</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;GVT cannot decrease from </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">!&quot;</span> 
                                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">,</span> <span class="n">gvt</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">gvt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">:</span>
            <span class="c"># The same, so don&#39;t do the batched fossil collection</span>
            <span class="c"># This will ALWAYS happen at the controller first, as this is the one that gets called with the GVT update first</span>
            <span class="c">#   if the value should change, it will do a complete round and finally set the variable</span>
            <span class="c">#   if the value stays the same, we can stop immediately</span>
            <span class="c">#assert info(&quot;Set GVT to %s&quot; % GVT)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_allocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gvt</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_allocator</span><span class="o">.</span><span class="n">getTerminationTime</span><span class="p">():</span>
                    <span class="c"># The initial allocator period is over, so switch to normal simulation</span>
                    <span class="n">relocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInitialAllocations</span><span class="p">()</span>
                    <span class="c"># Possibly, the locations are altered, so reset everything</span>
                    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">component_set</span><span class="p">:</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c"># Function pointers, so CamelCase</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">atomicOutputGeneration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomicOutputGeneration_backup</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">performRelocationsInit</span><span class="p">(</span><span class="n">relocs</span><span class="p">)</span>
                <span class="c"># Clear activities for now, as we don&#39;t want activity relocation medling in our affairs</span>
                <span class="n">activities</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">activities</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span> <span class="o">==</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span> <span class="ow">and</span> <span class="n">activities</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;activity-log&quot;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gvt</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">activities</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">horizon</span><span class="p">))</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">findAndPerformRelocations</span><span class="p">(</span><span class="n">gvt</span><span class="p">,</span> <span class="n">activities</span><span class="p">,</span> <span class="n">horizon</span><span class="p">)</span>
            <span class="c"># Otherwise: there was no pass in the GVT ring, indicating that no GVT progress was made</span>
            <span class="c"># This also indicates that the activities will NOT be reset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GVTdone</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">simlock_request</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simlock_request</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c">#assert debug(&quot;Set GVT to &quot; + str(GVT))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">old_gvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span> <span class="o">=</span> <span class="n">gvt</span>

            <span class="n">nqueue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">cleanup</span><span class="p">((</span><span class="n">gvt</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">performActions</span><span class="p">(</span><span class="n">gvt</span><span class="p">)</span>

            <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">gvt</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="p">[</span><span class="n">index</span><span class="p">:]</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">activities</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setGVT</span><span class="p">(</span><span class="n">gvt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">,</span> <span class="n">last_state_only</span><span class="p">)</span>
            <span class="n">addDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_activities</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporary_irreversible</span><span class="p">:</span>
                <span class="c">#print(&quot;Setting new state for %s models&quot; % len(self.model.component_set))</span>
                <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">component_set</span><span class="p">:</span>
                    <span class="n">activity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_activities</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">model_id</span><span class="p">]</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">old_states</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_saver</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">time_last</span><span class="p">,</span>
                                                         <span class="n">model</span><span class="o">.</span><span class="n">time_next</span><span class="p">,</span> 
                                                         <span class="n">model</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> 
                                                         <span class="n">activity</span><span class="p">,</span> 
                                                         <span class="bp">None</span><span class="p">,</span> 
                                                         <span class="bp">None</span><span class="p">)]</span>
                <span class="c">#TODO this is commented...</span>
                <span class="c">#self.totalActivities = defaultdict(float)</span>
            <span class="c"># Make a checkpoint too</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_freq</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Move the pending activities</span>
        <span class="k">if</span> <span class="n">last_state_only</span><span class="p">:</span>
            <span class="n">activity_sum</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">activity_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">activities</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">activity_sum</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_LP</span><span class="o">.</span><span class="n">setGVT</span><span class="p">(</span><span class="n">gvt</span><span class="p">,</span> <span class="n">activities</span><span class="p">,</span> <span class="n">last_state_only</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.revert"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.revert">[docs]</a>    <span class="k">def</span> <span class="nf">revert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Revert the current simulation kernel to the specified time. All messages</span>
<span class="sd">        sent after this time will be invalidated, all states produced after this</span>
<span class="sd">        time will be removed.</span>

<span class="sd">        :param time: the desired time for revertion.</span>

<span class="sd">        .. note:: Clearly, this time should be &gt;= the current GVT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Don&#39;t #assert that it is not irreversible, as an irreversible component could theoretically still be reverted, but this MUST be to a state when it was not yet irreversible</span>
        <span class="c"># Reverting the complete LP</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Reverting to time </span><span class="si">%f</span><span class="s">, before the GVT (</span><span class="si">%f</span><span class="s">)!&quot;</span> 
                                <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">))</span>
        <span class="c">#assert debug(&quot;Removing actions from time &quot; + str(time))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c">#assert debug(&quot;Revert to time &quot; + str(time) + &quot;, clock = &quot; + str(self.clock))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_some_tracing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">removeActions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="c"># Also revert the input message scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="c"># Now revert all local models</span>
        <span class="n">controller_revert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memoization</span><span class="p">)</span>
        <span class="c">#assert debug(&quot;Reverted all models&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="n">time</span>

        <span class="c"># Invalidate all output messages after or at time</span>
        <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">unschedules</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unschedules_mintime</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="p">):</span>
            <span class="c"># Do not invalidate messages at this time itself, as they are processed in this time step and not generated in this timestep</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">time</span><span class="p">:</span>
                <span class="n">model_id</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">destination</span>
                <span class="n">mintime</span> <span class="o">=</span> <span class="n">unschedules_mintime</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span>
                                                  <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">unschedules_mintime</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mintime</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
                <span class="n">unschedules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#assert debug(&quot;NOT invalidating &quot; + str(value.uuid))</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="p">[:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_outgoing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_outgoing</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Don&#39;t need the Vlock here, as we already have it</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">unschedules</span><span class="p">:</span>
            <span class="n">dest_kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dest_kernel</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Revertion due to relocation to self... This is impossible!&quot;</span><span class="p">)</span>
            <span class="n">mintime</span> <span class="o">=</span> <span class="n">unschedules_mintime</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
            <span class="c"># Assume we have the simlock already</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">dest_kernel</span><span class="p">,</span> <span class="n">mintime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">dest_kernel</span><span class="p">)</span><span class="o">.</span><span class="n">receiveAntiMessages</span><span class="p">(</span><span class="n">mintime</span><span class="p">,</span> 
                                                           <span class="n">model_id</span><span class="p">,</span> 
                                                           <span class="n">unschedules</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> 
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

        <span class="c"># Controller has read one of the reverted states, so force a rollback there</span>
        <span class="k">if</span> <span class="n">controller_revert</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">receiveAntiMessages</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.send"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.send">[docs]</a>    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare a message to be sent remotely and do the actual sending too.</span>

<span class="sd">        :param model_id: the id of the model that has to receive the message</span>
<span class="sd">        :param timestamp: timestamp of the message</span>
<span class="sd">        :param content: content of the message being sent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_outgoing</span> <span class="o">==</span> <span class="n">timestamp</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span><span class="p">):</span>
            <span class="c"># If the model was just reverted, we don&#39;t need to sent out these </span>
            <span class="c"># messages because they are already in the receivers queues.</span>
            <span class="c">#assert debug(&quot;Not sending message &quot; + str(timestamp))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">remote_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
        <span class="c"># NOTE the Vlock is already acquired by the sender</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">NetworkMessage</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> 
                             <span class="n">content</span><span class="p">,</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">genUUID</span><span class="p">(),</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> 
                             <span class="n">model_id</span><span class="p">)</span>

        <span class="c"># Assume we have the simlock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">remote_location</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

        <span class="c"># The message should be saved, though it should not be a copy. This is because the middleware will make</span>
        <span class="c"># a copy itself, making this old message unused. Furthermore, the receiver will always create a copy</span>
        <span class="c"># of the message to be safe, making a copy at the source unnecessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">remote_location</span><span class="p">)</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.receive"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.receive">[docs]</a>    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the kernel receive the provided message.</span>

<span class="sd">        The method will return as soon as possible to prevent a big number of pending messages.</span>
<span class="sd">        Furthermore, acquiring the locks here would be impractical since we only process all incomming messages one at a time.</span>

<span class="sd">        :param msg: a NetworkMessage to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># NOTE ports could change at run-time, though this is not a problem in distributed simulation!</span>
        <span class="c"># NOTE no need for locking, as all methods of a deque object is atomic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.processIncommingMessages"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.processIncommingMessages">[docs]</a>    <span class="k">def</span> <span class="nf">processIncommingMessages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process all incomming messages and return.</span>

<span class="sd">        This is part of the main simulation loop instead of being part of the message receive method, as we require the simlock for this. Acquiring the simlock elsewhere might take some time!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">dest_model</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">destination</span>
            <span class="k">if</span> <span class="n">dest_model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="p">:</span>
                <span class="c"># NOTE do it this way to make sure that anti message properties are conserved</span>
                <span class="c">#      furthermore, it prevents the message from being invalidated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">dest_model</span><span class="p">]</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>
                <span class="c"># No need to reencode the data, as it was still encoded</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c">#assert debug(&quot;Processing external msg: &quot; + str(msg))</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">dest_model</span><span class="p">]</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="p">{</span><span class="n">model</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span> <span class="n">msg</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">content</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">:</span>
                <span class="c"># Timestamp is before the prevtime</span>
                <span class="c"># so set the prevtime back in the past</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span><span class="p">:</span>
                <span class="c"># The prevtime is irrelevant, as we have finished simulation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

            <span class="c"># Now the message is an &#39;ordinary&#39; message, just schedule it for processing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.receiveAntiMessages"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.receiveAntiMessages">[docs]</a>    <span class="k">def</span> <span class="nf">receiveAntiMessages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mintime</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">uuids</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a (possibly huge) batch of anti messages for the same model</span>

<span class="sd">        :param mintime: the lowest timestamp of all messages being cancelled</span>
<span class="sd">        :param model_id: the model_id of the receiving model whose messages need to be negated, None to indicate a general rollback</span>
<span class="sd">        :param uuids: list of all uuids to cancel</span>
<span class="sd">        :param color: color for Mattern&#39;s algorithm</span>

<span class="sd">        .. note:: the *model_id* is only required to check whether or not the model is still local to us</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Important that this function is called oneway, as it can be called in such a way that it deadlocks otherwise</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">model_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span> <span class="ow">and</span> 
                            <span class="n">model_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                        <span class="n">destination</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span><span class="o">.</span><span class="n">receiveAntiMessages</span><span class="p">(</span><span class="n">mintime</span><span class="p">,</span> 
                                                                       <span class="n">model_id</span><span class="p">,</span> 
                                                                       <span class="n">uuids</span><span class="p">,</span> 
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">mintime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="n">mintime</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">:</span>
                        <span class="c"># Timestamp is before the prevtime</span>
                        <span class="c"># so set the prevtime back in the past</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">mintime</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span><span class="p">:</span>
                        <span class="c"># The prevtime is irrelevant, as we have finished simulation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="n">mintime</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">model_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">massUnschedule</span><span class="p">(</span><span class="n">uuids</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.check"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.check">[docs]</a>    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks wheter or not simulation should still continue. This will either</span>
<span class="sd">        call the global time termination check, or the local state termination</span>
<span class="sd">        check, depending on configuration.</span>

<span class="sd">        Using the global time termination check is a lot FASTER and should be used</span>
<span class="sd">        if possible.</span>

<span class="sd">        :returns: bool -- whether or not to stop simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Return True = stop simulation</span>
        <span class="c"># Return False = continue simulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="c"># Max loop checks</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Maximal number of 0 timeAdvance loops detected&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time_check</span><span class="p">:</span>
            <span class="c"># Finish at the termination time</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">readFirst</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span>
                    <span class="k">return</span> <span class="n">timestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c"># No message waiting to be processed, so finished</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Use a termination condition</span>
            <span class="c"># This code is only ran at the controller, as this is the only one with a termination condition</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">termination_condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_model</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finishAtTime</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finishAtTime</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.finishAtTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.finishAtTime">[docs]</a>    <span class="k">def</span> <span class="nf">finishAtTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clock</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Signal this kernel that it may stop at the provided time</span>

<span class="sd">        :param clock: the time to stop at</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">setTerminationTime</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.massDelayedActions"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.massDelayedActions">[docs]</a>    <span class="k">def</span> <span class="nf">massDelayedActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">msgs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the delayedAction function multiple times in succession.</span>

<span class="sd">        Mainly implemented to reduce the number of round trips when tracing.</span>

<span class="sd">        :param time: the time at which the action should happen</span>
<span class="sd">        :param msgs: list containing elements of the form (model_id, action)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">msgs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delayedAction</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.delayedAction"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.delayedAction">[docs]</a>    <span class="k">def</span> <span class="nf">delayedAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform an irreversible action (I/O, prints, global messages, ...). All</span>
<span class="sd">        these actions will be performed in the order they should be generated</span>
<span class="sd">        in a non-distributed simulation. All these messages might be reverted in</span>
<span class="sd">        case a revertion is performed by the calling model.</span>

<span class="sd">        :param time: the simulation time at which this command was requested</span>
<span class="sd">        :param model_id: the model_id of the model that requested this command</span>
<span class="sd">        :param action: the actual command to be executed as soon as it is safe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#assert debug(&quot;Adding action for time &quot; + str(time) + &quot;, GVT = &quot; + str(self.GVT))</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Can&#39;t execute action (</span><span class="si">%s</span><span class="s">) before the GVT (</span><span class="si">%s</span><span class="s">)!&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="ow">and</span> 
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> 
                <span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">performActions</span><span class="p">()</span>
        <span class="c"># An append is an atomic action, though we need to lock it as other operations on it arent&#39; atomic</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="BaseSimulator.removeActions"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.removeActions">[docs]</a>    <span class="k">def</span> <span class="nf">removeActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all actions specified by a model, starting from a specified time.</span>
<span class="sd">        This function should be called when the model is reverted and its actions</span>
<span class="sd">        have to be undone</span>

<span class="sd">        :param model_ids: the model_ids of all reverted models</span>
<span class="sd">        :param time: time up to which to remove all actions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Cannot remove action (</span><span class="si">%s</span><span class="s">) before the GVT (</span><span class="si">%s</span><span class="s">)!&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">))</span>
        <span class="c">#assert debug(&quot;Removing actions for time &quot; + str(time) + &quot; and for ids &quot; + str(model_ids))</span>
        <span class="c"># Actions are unsorted, so we have to go through the complete list</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> 
                              <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">))]</span>
</div>
<div class="viewcode-block" id="BaseSimulator.performActions"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.performActions">[docs]</a>    <span class="k">def</span> <span class="nf">performActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gvt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform all irreversible actions up to the provided time.</span>
<span class="sd">        If time is not specified, all queued actions will be executed (in case simulation is finished)</span>

<span class="sd">        :param gvt: the time up to which all actions should be executed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gvt</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">termination_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="c"># But crop of to the termination_time as we might have simulated slightly too long</span>
            <span class="n">gvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">EPSILON</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gvt</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                <span class="c"># Only take the relevant part to sort, this will decrease complexity</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">remainder</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gvt</span><span class="p">:</span>
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">remainder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span>
                <span class="n">remainder</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="n">remainder</span>
            <span class="c"># Release the lock ASAP, to allow other actions to be performed</span>

        <span class="c"># Sort on time first, then on MESSAGE, not on model</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

        <span class="c"># Now execute each action in order</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="BaseSimulator.removeTracers"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.removeTracers">[docs]</a>    <span class="k">def</span> <span class="nf">removeTracers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all currently registered tracers. This does not clean them up, as this should already be done by the code at the end of the simulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setGlobals"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setGlobals">[docs]</a>    <span class="k">def</span> <span class="nf">setGlobals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                   <span class="n">address</span><span class="p">,</span> 
                   <span class="n">loglevel</span><span class="p">,</span> 
                   <span class="n">checkpoint_frequency</span><span class="p">,</span> 
                   <span class="n">checkpoint_name</span><span class="p">,</span> 
                   <span class="n">statesaver</span><span class="p">,</span> 
                   <span class="n">kernels</span><span class="p">,</span> 
                   <span class="n">msg_copy</span><span class="p">,</span> 
                   <span class="n">memoization</span><span class="p">,</span> 
                   <span class="n">tracers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure all &#39;global&#39; variables for this kernel</span>

<span class="sd">        :param address: address of the syslog server</span>
<span class="sd">        :param loglevel: level of logging library</span>
<span class="sd">        :param checkpoint_frequency: frequency at which checkpoints should be made</span>
<span class="sd">        :param checkpoint_name: name of the checkpoint to save</span>
<span class="sd">        :param statesaver: statesaving method</span>
<span class="sd">        :param kernels: number of simulation kernels in total</span>
<span class="sd">        :param msg_copy: message copy method</span>
<span class="sd">        :param memoization: use memoization or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tracer</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">registerTracer</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_some_tracing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">hasTracers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglevel</span> <span class="o">=</span> <span class="n">loglevel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernels</span> <span class="o">=</span> <span class="n">kernels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">kernels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernels</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporary_irreversible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span>
        <span class="n">state_saving_options</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">DeepCopyState</span><span class="p">,</span> 
                                <span class="mi">1</span><span class="p">:</span> <span class="n">PickleZeroState</span><span class="p">,</span> 
                                <span class="mi">2</span><span class="p">:</span> <span class="n">PickleHighestState</span><span class="p">,</span> 
                                <span class="mi">3</span><span class="p">:</span> <span class="n">CopyState</span><span class="p">,</span> 
                                <span class="mi">4</span><span class="p">:</span> <span class="n">AssignState</span><span class="p">,</span> 
                                <span class="mi">5</span><span class="p">:</span> <span class="n">CustomState</span><span class="p">,</span> 
                                <span class="mi">6</span><span class="p">:</span> <span class="n">MarshalState</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_saver</span> <span class="o">=</span> <span class="n">state_saving_options</span><span class="p">[</span><span class="n">statesaver</span><span class="p">]</span>
        <span class="c"># Save the integer value for checkpointing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_saving</span> <span class="o">=</span> <span class="n">statesaver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_copy</span> <span class="o">=</span> <span class="n">msg_copy</span>
        <span class="n">setLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">loglevel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_name</span> <span class="o">=</span> <span class="n">checkpoint_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_freq</span> <span class="o">=</span> <span class="n">checkpoint_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memoization</span> <span class="o">=</span> <span class="n">memoization</span>
</div>
<div class="viewcode-block" id="BaseSimulator.processMessage"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.processMessage">[docs]</a>    <span class="k">def</span> <span class="nf">processMessage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clock</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the first external message smaller than the clock and process them if necessary. Return the new time_next for simulation.</span>

<span class="sd">        :param clock: timestamp of the next internal transition</span>
<span class="sd">        :returns: timestamp of the next transition, taking into account external messages</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">readFirst</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c"># No input messages</span>
            <span class="k">return</span> <span class="n">clock</span>
        <span class="k">if</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">clock</span><span class="p">:</span>
            <span class="c"># The message is sent before the timenext, so update the clock</span>
            <span class="n">clock</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">clock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">EPSILON</span> <span class="ow">and</span> 
                    <span class="p">(</span><span class="n">clock</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">:</span>
                    <span class="n">aDEVS</span> <span class="o">=</span> <span class="n">port</span><span class="o">.</span><span class="n">host_DEVS</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="n">port</span><span class="p">]</span>
                    <span class="n">aDEVS</span><span class="o">.</span><span class="n">my_input</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">[</span><span class="n">aDEVS</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">removeFirst</span><span class="p">()</span>
                <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span><span class="o">.</span><span class="n">readFirst</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c"># At the end of the scheduler, so we are done</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">clock</span>
</div>
<div class="viewcode-block" id="BaseSimulator.realtimeWait"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.realtimeWait">[docs]</a>    <span class="k">def</span> <span class="nf">realtimeWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the waiting for input required in realtime simulation.</span>

<span class="sd">        The time_next of the model will be updated accordingly and all messages will be routed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># NOTE a scale of 2 means that simulation will take twice as long</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">performActions</span><span class="p">()</span>
        <span class="c"># Wait for the determined period of time</span>
        <span class="n">current_realtime_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt_zerotime</span><span class="p">)</span>
        <span class="n">scaled_realtime_time</span> <span class="o">=</span> <span class="n">current_realtime_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtime_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asynchronous_generator</span><span class="o">.</span><span class="n">checkInterrupt</span><span class="p">(</span><span class="n">scaled_realtime_time</span><span class="p">)</span>
        <span class="n">next_sim_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                          <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                          <span class="bp">self</span><span class="o">.</span><span class="n">asynchronous_generator</span><span class="o">.</span><span class="n">getNextTime</span><span class="p">())</span>
        <span class="c"># Scaled realtime</span>
        <span class="n">next_sim_time</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtime_scale</span>

        <span class="c"># Subtract the time that we already did our computation</span>
        <span class="n">wait_time</span> <span class="o">=</span> <span class="n">next_sim_time</span> <span class="o">-</span> <span class="n">current_realtime_time</span>
        <span class="n">interrupt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threading_backend</span><span class="o">.</span><span class="n">getInterrupt</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">interrupt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">portname</span><span class="p">,</span> <span class="n">event_value</span> <span class="o">=</span> <span class="n">interrupt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)</span>
                <span class="n">event_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">portmap</span><span class="p">[</span><span class="n">portname</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c"># Couldn&#39;t split, means we should stop</span>
                <span class="kn">import</span> <span class="nn">sys</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c"># Process the input</span>
            <span class="c">#NOTE no distinction between PDEVS and CDEVS is necessary, as CDEVS is internally handled just like PDEVS</span>
            <span class="c">#     wrappers are provided to &#39;unpack&#39; the list structure</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="n">event_port</span><span class="p">:</span> <span class="p">[</span><span class="n">event_value</span><span class="p">]}</span>
            <span class="n">event_port</span><span class="o">.</span><span class="n">host_DEVS</span><span class="o">.</span><span class="n">my_input</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">[</span><span class="n">event_port</span><span class="o">.</span><span class="n">host_DEVS</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">time_diff</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt_zerotime</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_diff</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtime_scale</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c"># Transition</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">wait_time</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Transition</span>
            <span class="c">#NOTE actually, we should set the time_next here too...</span>
            <span class="c">#     otherwise we will always have a &#39;perfect&#39; time_next</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We have to wait some more for the next time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threading_backend</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">wait_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">runsim</span><span class="p">)</span>
            <span class="c"># Don&#39;t transition but stop</span>
            <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseSimulator.runsim"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.runsim">[docs]</a>    <span class="k">def</span> <span class="nf">runsim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run a complete simulation run. Can be run multiple times if this is required in e.g. a distributed simulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtimeWait</span><span class="p">():</span>
                <span class="c"># Make implicit use of shortcut evaluation,</span>
                <span class="c"># The realtimeWait method will return True if it forces a simulation stop</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
                    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">processIncommingMessages</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

            <span class="c"># Only do the check here, after setting the next time of the simulation</span>
            
            <span class="c"># All priority threads are cleared, so obtain the simulation lock ourself</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock_request</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.00001</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="c"># Process all incomming messages</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span><span class="p">:</span>
                    <span class="c"># Check the external messages only if there is a possibility for them to arrive</span>
                    <span class="c"># This is a slight optimisation for local simulation</span>
                    <span class="n">tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processMessage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span>
                <span class="k">if</span> <span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                    <span class="c"># Always break, even if the terminiation condition/time was wrong</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtime_finished</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="n">cDEVS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
                <span class="c"># Round of the current clock time, which is necessary for revertions later on</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_clock</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">),</span> <span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="c"># Don&#39;t interrupt the output generation, as these nodes WILL be marked as &#39;sent&#39;</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="n">reschedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupledOutputGeneration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_clock</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">massAtomicTransitions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_clock</span><span class="p">)</span>
                    <span class="n">cDEVS</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">massReschedule</span><span class="p">(</span><span class="n">reschedule</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_DSDEVS</span><span class="p">:</span>
                        <span class="c"># Check for dynamic structure simulation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">performDSDEVS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">QuickStopException</span><span class="p">:</span>
                    <span class="c"># For relocations that should interrupt the simulation algorithm</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                    <span class="k">continue</span>

                <span class="c"># Put this in a lock to prevent a possible infinite time_next from reading the prevtime with the old value</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="c"># Fetch the next time of a transition</span>
                    <span class="n">cDEVS</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
                    <span class="c"># Clear all transitioning elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="c"># No longer block any output messages</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block_outgoing</span> <span class="o">=</span> <span class="bp">None</span>

                    <span class="c"># self.clock now contains the time at which NO messages were sent</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_clock</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span>
</div>
<div class="viewcode-block" id="BaseSimulator.finishRing"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.finishRing">[docs]</a>    <span class="k">def</span> <span class="nf">finishRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg_sent</span><span class="p">,</span> <span class="n">msg_recv</span><span class="p">,</span> <span class="n">first_run</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Go over the ring and ask each kernel whether it is OK to stop simulation</span>
<span class="sd">        or not. Uses a count to check that no messages are yet to be processed.</span>

<span class="sd">        :param msg_sent: current counter for total amount of sent messages</span>
<span class="sd">        :param msg_recv: current counter for total amount of received messages</span>
<span class="sd">        :param first_run: whether or not to forward at the controller</span>
<span class="sd">        :returns: int -- amount of messages received and sent (-1 signals running simulation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#NOTE due to the MPI backend changing None to 0, we need to return something else, like a -1...</span>
        <span class="c"># Try to obtain the simulation lock first</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="c"># It was already taken, so something is still working</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">isSet</span><span class="p">():</span>
                <span class="c"># We should still run</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first_run</span><span class="p">:</span>
                <span class="c"># We are done, so return if they are equal</span>
                <span class="k">if</span> <span class="n">msg_sent</span> <span class="o">==</span> <span class="n">msg_recv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">msg_sent</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Some messages are not yet received, so not correct</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># Always release the simlock when we got it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="c"># Ask the next node for its situation</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_LP</span><span class="o">.</span><span class="n">finishRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_sent</span> <span class="o">+</span> <span class="n">msg_sent</span><span class="p">,</span> 
                                       <span class="bp">self</span><span class="o">.</span><span class="n">msg_recv</span> <span class="o">+</span> <span class="n">msg_recv</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.checkpoint"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.checkpoint">[docs]</a>    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a checkpoint of the current basesimulator, this function will assume</span>
<span class="sd">        that no messages are still left in the medium, since these are obviously</span>
<span class="sd">        not saved by pickling the base simulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># pdc = PythonDevs Checkpoint</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">.pdc&quot;</span> 
                       <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_name</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="c"># If the model was flattened when it was sent to this node, we will also need to flatten it while checkpointing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">flattenConnections</span><span class="p">()</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span><span class="p">:</span>
            <span class="c"># Don&#39;t forget to unflatten!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">unflattenConnections</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.loadCheckpoint"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.loadCheckpoint">[docs]</a>    <span class="k">def</span> <span class="nf">loadCheckpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alert this kernel that it is restoring from a checkpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Overwrite variables for GVT algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_msg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">tracerlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setGlobals</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> 
                        <span class="n">loglevel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loglevel</span><span class="p">,</span> 
                        <span class="n">tracers</span><span class="o">=</span><span class="n">tracerlist</span><span class="p">,</span>
                        <span class="n">memoization</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memoization</span><span class="p">,</span>
                        <span class="n">checkpoint_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_name</span><span class="p">,</span>
                        <span class="n">checkpoint_frequency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_freq</span><span class="p">,</span> 
                        <span class="n">statesaver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_saving</span><span class="p">,</span> 
                        <span class="n">kernels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kernels</span><span class="p">,</span>
                        <span class="n">msg_copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_copy</span><span class="p">)</span>
        <span class="c"># Still unflatten the model if it was flattened (due to pickling limit)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">unflattenConnections</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">msg_sent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_recv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="c">#self.inqueue = Queue.Queue()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c"># Just perform a revertion</span>
        <span class="c"># but clear the queues first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># and the inputQueue, since every model will be reset to GVT</span>
        <span class="c">#  everything that happens before GVT can be cleared by revertion</span>
        <span class="c">#  everything that happens after GVT will be replicated by the external models</span>
        <span class="c"># Useful, since this also allows us to skip saving all this info in the pickled data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_scheduler</span> <span class="o">=</span> <span class="n">MessageScheduler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseSimulator.simulate_sync"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.simulate_sync">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A small wrapper around the simulate() function, though with a different name to allow a much simpler MPI one way check</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.simulate"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate at this kernel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">had_lock</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">had_lock</span><span class="p">:</span>
            <span class="c"># We already had the lock, so normal simulation</span>
            <span class="c"># Send the init message</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span> <span class="o">==</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                <span class="c"># To make sure that the GVT algorithm won&#39;t start already and see that this</span>
                <span class="c"># model has nothing to simulate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_next</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coupledInit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We didn&#39;t have the lock yet, so this is a continueing simulation</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

        <span class="n">controller</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runsim</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_finish</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runsim</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">should_run</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_finish</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setAttr"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setAttr">[docs]</a>    <span class="k">def</span> <span class="nf">setAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an attribute of a model.</span>

<span class="sd">        :param model_id: the id of the model to alter</span>
<span class="sd">        :param attr: string representation of the attribute to alter</span>
<span class="sd">        :param value: value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setStateAttr"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setStateAttr">[docs]</a>    <span class="k">def</span> <span class="nf">setStateAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an attribute of the state of a model</span>

<span class="sd">        :param model_id: the id of the model to alter</span>
<span class="sd">        :param attr: string representation of the attribute to alter</span>
<span class="sd">        :param value: value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.startTracers"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.startTracers">[docs]</a>    <span class="k">def</span> <span class="nf">startTracers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start all tracers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">startTracers</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.stopTracers"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.stopTracers">[docs]</a>    <span class="k">def</span> <span class="nf">stopTracers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stop all tracers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">stopTracers</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getGVT"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getGVT">[docs]</a>    <span class="k">def</span> <span class="nf">getGVT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the GVT of this kernel</span>

<span class="sd">        :returns: float -- the current GVT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gvt</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getTime">[docs]</a>    <span class="k">def</span> <span class="nf">getTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current time of this kernel</span>

<span class="sd">        :returns: float -- the current simulation time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getState"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getState">[docs]</a>    <span class="k">def</span> <span class="nf">getState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the state of the specified model</span>

<span class="sd">        :param model_id: the model_id of the model of which the state is requested</span>
<span class="sd">        :returns: state -- the state of the requested model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">state</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getStateAtTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getStateAtTime">[docs]</a>    <span class="k">def</span> <span class="nf">getStateAtTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">request_time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the state of a model at a specific time</span>

<span class="sd">        :param model_id: model_id of which the state should be fetched</span>
<span class="sd">        :param request_time: time of the state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">getState</span><span class="p">(</span><span class="n">request_time</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.genUUID"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.genUUID">[docs]</a>    <span class="k">def</span> <span class="nf">genUUID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a unique enough ID for a message</span>

<span class="sd">        :returns: string -- a unique string for the specific name and number of sent messages</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_msg_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_msg_counter</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getLocation"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getLocation">[docs]</a>    <span class="k">def</span> <span class="nf">getLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the location at which the model with the provided model_id runs</span>

<span class="sd">        :param model_id: the model_id of the model of which the location is requested</span>
<span class="sd">        :returns: int -- the number of the kernel where the provided model_id runs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fetched</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fetched</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fetched</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getActivity"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getActivity">[docs]</a>    <span class="k">def</span> <span class="nf">getActivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the activity for a certain model id from the previous iteration</span>

<span class="sd">        :param model_id: the model_id to check</span>
<span class="sd">        :returns: float -- the activity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getCompleteActivity"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getCompleteActivity">[docs]</a>    <span class="k">def</span> <span class="nf">getCompleteActivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the complete dictionary of all activities</span>

<span class="sd">        :returns: dict -- mapping of all activities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getTotalActivity"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getTotalActivity">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalActivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">))):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary containing the total activity through the complete simulation run</span>

<span class="sd">        :param time: time up to which to return activity</span>
<span class="sd">        :returns: dict -- mapping of all activities, but simulation-wide</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span><span class="p">:</span>
            <span class="n">activities</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fetchActivity</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">activities</span><span class="p">)</span>
            <span class="n">addDict</span><span class="p">(</span><span class="n">activities</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_activities</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">activities</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_activities</span>
</div>
<div class="viewcode-block" id="BaseSimulator.recomputeTA"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.recomputeTA">[docs]</a>    <span class="k">def</span> <span class="nf">recomputeTA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recompute the timeAdvance of a specific model and reapply it. It should only be called after the model was changed using one of the provided functions.</span>
<span class="sd">        The change will seemingly have happened right after the last simulation step, so your timeAdvance should **NOT** return something smaller than this.</span>
<span class="sd">        The actual *absolute* time_next will be determined at the time of the last transition too. If the model was not altered in a way that causes a major change</span>
<span class="sd">        to the state, the *elapsed* time attribute will take care of this call perfectly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;scheduler&quot;</span><span class="p">):</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
            <span class="c"># Termination time will always be correct</span>
            <span class="n">model</span><span class="o">.</span><span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">time_last</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">timeAdvance</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">time_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">elapsed</span> <span class="o">+</span> <span class="n">ta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">time_next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Model user modification causes a transition in the past&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">massReschedule</span><span class="p">([</span><span class="n">model</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We have not yet run coupledInit, so this will happen automatically</span>
            <span class="k">pass</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">PythonPDEVS 2.3.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Yentl Van Tendeloo.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3a0.
    </div>
  </body>
</html>